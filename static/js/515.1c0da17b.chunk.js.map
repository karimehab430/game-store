{"version":3,"file":"static/js/515.1c0da17b.chunk.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js","../node_modules/@tanstack/react-query/src/IsRestoringProvider.ts","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/suspense.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { timeoutManager } from './timeoutManager'\nimport type { ManagedTimerId } from './timeoutManager'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ManagedTimerId\n  #refetchIntervalId?: ManagedTimerId\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        if (key === 'promise') {\n          this.trackProp('data')\n          if (\n            !this.options.experimental_prefetchInRender &&\n            this.#currentThenable.status === 'pending'\n          ) {\n            this.#currentThenable.reject(\n              new Error(\n                'experimental_prefetchInRender feature flag is not enabled',\n              ),\n            )\n          }\n        }\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure \" + obj);\n}","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => {\n  const throwOnError =\n    query?.state.error && typeof options.throwOnError === 'function'\n      ? shouldThrowError(options.throwOnError, [query.state.error, query])\n      : options.throwOnError\n\n  if (\n    options.suspense ||\n    options.experimental_prefetchInRender ||\n    throwOnError\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n","import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n    const MIN_SUSPENSE_TIME_MS = 1000\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static'\n        ? value\n        : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(\n        defaultedOptions.gcTime,\n        MIN_SUSPENSE_TIME_MS,\n      )\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n"],"names":["QueryObserver","_client","WeakMap","_currentQuery","_currentQueryInitialState","_currentResult","_currentResultState","_currentResultOptions","_currentThenable","_selectError","_selectFn","_selectResult","_lastQueryWithDefinedData","_staleTimeoutId","_refetchIntervalId","_currentRefetchInterval","_trackedProps","_executeFetch","WeakSet","_updateStaleTimeout","_computeRefetchInterval","_updateRefetchInterval","_updateTimers","_clearStaleTimeout","_clearRefetchInterval","_updateQuery","_notify","_Subscribable","_inherits","_super","_createSuper","client","options","_this","_classCallCheck","call","_classPrivateMethodInitSpec","_assertThisInitialized","_classPrivateFieldInitSpec","writable","value","Set","_classPrivateFieldSet","pendingThenable","bindMethods","setOptions","_createClass","key","this","refetch","bind","listeners","size","_classPrivateFieldGet","addObserver","shouldFetchOnMount","_classPrivateMethodGet","_executeFetch2","updateResult","_updateTimers2","hasListeners","destroy","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","_clearStaleTimeout2","_clearRefetchInterval2","removeObserver","prevOptions","prevQuery","defaultQueryOptions","enabled","resolveEnabled","Error","_updateQuery2","_defaulted","shallowEqualObjects","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","resolveStaleTime","staleTime","_updateStaleTimeout2","nextRefetchInterval","_computeRefetchInterval2","_updateRefetchInterval2","build","result","createResult","optimisticResult","getCurrentResult","shouldAssignObserverCurrentProperties","state","onPropTracked","_this2","Proxy","get","target","trackProp","experimental_prefetchInRender","status","reject","Reflect","add","_ref","arguments","length","undefined","Object","assign","obj","TypeError","_objectDestructuringEmpty","fetch","_objectSpread","_this3","defaultedOptions","then","fetchOptions","_fetchOptions$cancelR","_this4","cancelRefetch","data","_this5","prevResult","prevResultState","prevResultOptions","queryInitialState","newState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","fetchState","fetchStatus","_newState","error","errorUpdatedAt","skipSelect","placeholderData","_classPrivateFieldGet2","replaceData","select","selectError","Date","now","isFetching","isPending","isError","isLoading","hasData","nextResult","isSuccess","isInitialLoading","dataUpdatedAt","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isStale","promise","isEnabled","finalizeThenableIfPossible","thenable","resolve","recreateThenable","pending","prevThenable","queryHash","reason","_this6","_notify2","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","throwOnError","keys","some","typedKey","has","shouldNotifyListeners","Subscribable","catch","noop","_this7","isServer","isValidTimeout","timeout","timeUntilStale","timeoutManager","setTimeout","_ref2","refetchInterval","nextInterval","_this8","setInterval","refetchIntervalInBackground","focusManager","isFocused","clearTimeout","clearInterval","notifyOptions","_this9","notifyManager","batch","forEach","listener","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","isStaleByTime","IsRestoringContext","React","useIsRestoring","Provider","createValue","isReset","clearReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","errorResetBoundary","shouldThrowError","useClearResetErrorBoundary","getHasError","ensureSuspenseTimers","MIN_SUSPENSE_TIME_MS","clamp","Math","max","originalStaleTime","apply","gcTime","willFetch","isRestoring","shouldSuspend","fetchOptimistic"],"sourceRoot":""}